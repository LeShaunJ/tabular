# <%= shell %> completion for <%= program %> -*- shell-script -*-
# See: https://github.com/spf13/cobra/raw/refs/heads/main/<%= shell %>_completionsV2.go
<%- unless alternate.empty? %>
alias <%= program %>='<%= alternate %>'
<% end -%>

__<%= var_name %>_debug() {
	echo "$*" >> "${TABULAR_LOG_FILE:-/dev/null}"
}

__<%= var_name %>_init_completion() {
	COMPREPLY=()
	_get_comp_words_by_ref "$@" cur prev words cword
}

__<%= var_name %>_get_completion_results() {
	local requestComp lastParam lastChar args

	args=("${words[@]:1}")
	requestComp="${words[0]} <%= command %> ${args[@]}"

	lastParam=${words[$((${#words[@]}-1))]}
	lastChar=${lastParam:$((${#lastParam}-1)):1}
	__<%= var_name %>_debug "lastParam ${lastParam}, lastChar ${lastChar}"

	if [[ -z ${cur} && ${lastChar} != = ]]; then
		__<%= var_name %>_debug "Adding extra empty parameter"
		requestComp="${requestComp} ''"
	fi

	if [[ ${cur} == -*=* ]]; then
		cur="${cur#*=}"
	fi

	__<%= var_name %>_debug "Calling ${requestComp}"
	out=$(eval "${requestComp}" 2>/dev/null)

	directive=${out##*:}
	out=${out%:*}
	if [[ ${directive} == "${out}" ]]; then
		directive=0
	fi
	__<%= var_name %>_debug "The completion directive is: ${directive}"
	__<%= var_name %>_debug "The completions are: ${out}"
}

__<%= var_name %>_process_completion_results() {
	local shellCompDirectiveError=<%= Directive::Error.value %>
	local shellCompDirectiveNoSpace=<%= Directive::NoSpace.value %>
	local shellCompDirectiveNoFileComp=<%= Directive::NoFile.value %>
	local shellCompDirectiveFilterFileExt=<%= Directive::FilterExt.value %>
	local shellCompDirectiveFilterDirs=<%= Directive::FilterDir.value %>
	local shellCompDirectiveKeepOrder=<%= Directive::KeepOrder.value %>

	if (( directive & shellCompDirectiveError )); then
		__<%= var_name %>_debug "Received error from custom completion go code"
		return
	fi

	__set_compopt() {
		compopt "${1}" "${2}" 2>/dev/null &&
			__<%= var_name %>_debug "Activated ${2}" ||
			__<%= var_name %>_debug "Directive '${2}' not supported in this version of bash";
	}

	(( directive & shellCompDirectiveNoSpace )) && __set_compopt -o nospace
	(( directive & shellCompDirectiveKeepOrder )) && __set_compopt -o nosort
	(( directive & shellCompDirectiveNoFileComp )) && __set_compopt +o default

	local completions=()
	local activeHelp=()
	__<%= var_name %>_extract_activeHelp

	if (( directive & shellCompDirectiveFilterFileExt )); then
		local fullFilter="" filter filteringCmd

		for filter in ${completions[*]}; do
			fullFilter+="$filter|"
		done

		filteringCmd="_filedir $fullFilter"
		__<%= var_name %>_debug "File filtering command: $filteringCmd"
		$filteringCmd
	elif (( directive & shellCompDirectiveFilterDirs )); then
		local subdir
		subdir=${completions[0]}

		if [[ -n $subdir ]]; then
			__<%= var_name %>_debug "Listing directories in $subdir"
			pushd "$subdir" >/dev/null 2>&1 && _filedir -d && popd >/dev/null 2>&1 || return
		else
			__<%= var_name %>_debug "Listing directories in ."
			_filedir -d
		fi
	else
		__<%= var_name %>_handle_completion_types
	fi

	__<%= var_name %>_handle_special_char "$cur" :
	__<%= var_name %>_handle_special_char "$cur" =

	__<%= var_name %>_handle_activeHelp
}

__<%= var_name %>_handle_activeHelp() {
	if (( ${#activeHelp[*]} )); then
		if [ -z $COMP_TYPE ]; then
			printf "\n";
			printf "%s\n" "${activeHelp[@]}"
			printf "\n"
			__<%= var_name %>_reprint_commandLine
			return
		fi

		if [ $COMP_TYPE -eq 63 ]; then
			printf "\n"
			printf "%s\n" "${activeHelp[@]}"

			if (( ${#COMPREPLY[*]} == 0 )); then
				if (((directive & shellCompDirectiveNoFileComp) == 0)); then
					__<%= var_name %>_debug "Listing files"
					_filedir
				fi
			fi

			if (( ${#COMPREPLY[*]} )); then
				printf -- "--"
			else
				__<%= var_name %>_reprint_commandLine
			fi
		elif [ $COMP_TYPE -eq 37 ] || [ $COMP_TYPE -eq 42 ]; then
			printf "\n"
			printf "%s\n" "${activeHelp[@]}"

			__<%= var_name %>_reprint_commandLine
		fi
	fi
}

__<%= var_name %>_reprint_commandLine() {
	if (x=${PS1@P}) 2> /dev/null; then
		printf "%s" "${PS1@P}${COMP_LINE[@]}"
	else
		printf "%s" "${COMP_LINE[@]}"
	fi
}

__<%= var_name %>_extract_activeHelp() {
	local activeHelpMarker="<%= ACTIVE_HELP_MARKER %>"
	local endIndex=${#activeHelpMarker}

	while IFS='' read -r comp; do
		[[ -z $comp ]] && continue

		if [[ ${comp:0:endIndex} == $activeHelpMarker ]]; then
			comp=${comp:endIndex}
			__<%= var_name %>_debug "ActiveHelp found: $comp"
			if [[ -n $comp ]]; then
				activeHelp+=("$comp")
			fi
		else
			completions+=("$comp")
		fi
	done <<<"${out}"
}

__<%= var_name %>_handle_completion_types() {
	__<%= var_name %>_debug "__<%= var_name %>_handle_completion_types: COMP_TYPE is $COMP_TYPE"

	case $COMP_TYPE in
		37|42)
			(( ${#completions[@]} == 0 )) && return 0

			local tab=$'\t'
			IFS=$'\n' read -ra completions -d '' < <(printf "%q\n" "${completions[@]%%$tab*}")
			IFS=$'\n' read -ra COMPREPLY -d '' < <(IFS=$'\n'; compgen -W "${completions[*]}" -- "${cur}")
			IFS=$'\n' read -ra COMPREPLY -d '' < <(printf "%q\n" "${COMPREPLY[@]}")
			;;
		*)
			__<%= var_name %>_handle_standard_completion_case
			;;
	esac
}

__<%= var_name %>_handle_standard_completion_case() {
	local tab=$'\t'

	(( ${#completions[@]} == 0 )) && return 0

	if [[ "${completions[*]}" != *$tab* ]]; then
		IFS=$'\n' read -ra completions -d '' < <(printf "%q\n" "${completions[@]}")
		IFS=$'\n' read -ra COMPREPLY -d '' < <(IFS=$'\n'; compgen -W "${completions[*]}" -- "${cur}")

		if (( ${#COMPREPLY[@]} == 1 )); then
			COMPREPLY[0]=$(printf "%q" "${COMPREPLY[0]}")
		fi
		return 0
	fi

	local longest=0
	local compline
	while IFS='' read -r compline; do
		[[ -z $compline ]] && continue

		printf -v comp "%q" "${compline%%$tab*}" &>/dev/null || comp=$(printf "%q" "${compline%%$tab*}")

		[[ $comp == "$cur"* ]] || continue

		COMPREPLY+=("$compline")

		comp=${compline%%$tab*}
		if ((${#comp}>longest)); then
			longest=${#comp}
		fi
	done < <(printf "%s\n" "${completions[@]}")

	if (( ${#COMPREPLY[*]} == 1 )); then
		__<%= var_name %>_debug "COMPREPLY[0]: ${COMPREPLY[0]}"
		COMPREPLY[0]=$(printf "%q" "${COMPREPLY[0]%%$tab*}")
		__<%= var_name %>_debug "Removed description from single completion, which is now: ${COMPREPLY[0]}"
	else
		__<%= var_name %>_format_comp_descriptions $longest
	fi
}

__<%= var_name %>_handle_special_char() {
	local comp="$1"
	local char=$2
	if [[ "$comp" == *${char}* && "$COMP_WORDBREAKS" == *${char}* ]]; then
		local word=${comp%"${comp##*${char}}"}
		local idx=${#COMPREPLY[*]}
		while (( --idx >= 0 )); do
			COMPREPLY[idx]=${COMPREPLY[idx]#"$word"}
		done
	fi
}

__<%= var_name %>_format_comp_descriptions() {
	local tab=$'\t'
	local comp desc maxdesclength
	local longest=$1

	local i ci
	for ci in ${!COMPREPLY[*]}; do
		comp=${COMPREPLY[ci]}
		if [[ "$comp" == *$tab* ]]; then
			__<%= var_name %>_debug "Original comp: $comp"
			desc=${comp#*$tab}
			comp=${comp%%$tab*}

			maxdesclength=$(( COLUMNS - longest - 4 ))

			if (( maxdesclength > 8 )); then
				for (( i = ${#comp} ; i < longest ; i++ )); do
					comp+=" "
				done
			else
				maxdesclength=$(( COLUMNS - ${#comp} - 4 ))
			fi

			if (( maxdesclength > 0 )); then
				if (( ${#desc} > maxdesclength )); then
					desc=${desc:0:$(( maxdesclength - 1 ))}
					desc+="â€¦"
				fi
				comp+="  ($desc)"
			fi
			COMPREPLY[ci]=$comp
			__<%= var_name %>_debug "Final comp: $comp"
		fi
	done
}

__start_<%= var_name %>() {
	local cur prev words cword split

	COMPREPLY=()

	if declare -F _init_completion >/dev/null 2>&1; then
		_init_completion -n =: || return
	else
		__<%= var_name %>_init_completion -n =: || return
	fi

	__<%= var_name %>_debug
	__<%= var_name %>_debug "========= starting completion logic =========="
	__<%= var_name %>_debug "cur is ${cur}, words[*] is ${words[*]}, #words[@] is ${#words[@]}, cword is $cword"

	words=("${words[@]:0:$cword+1}")
	__<%= var_name %>_debug "Truncated words[*]: ${words[*]},"

	local out directive
	__<%= var_name %>_get_completion_results
	__<%= var_name %>_process_completion_results
}

if [[ $(type -t compopt) = "builtin" ]]; then
	complete -o default -F __start_<%= var_name %> <%= program %>
else
	complete -o default -o nospace -F __start_<%= var_name %> <%= program %>
fi

# ex: ts=4 sw=4 et filetype=sh
